### rabbitmq
---
### rabbitmq介绍
1. Erlang 语言开发，基于AMQP协议实现的消息队列，是应用程序之间的通信方法
2. 使用场景
    ```
     1. 异步任务：不需要同步处理并且耗时教程的操作有消息队列通知消息接受方法异步处理，提高应用程序的相应时间
     2. 应用程序解耦：MQ相当于一个中介，生产方通过MQ与消费方交互，将应用程序进行解耦
        
    ```
3. 为什么使用RabbitMQ
   ```
    1. Springboot默认集成RabbitMQ
    2. 使用简单，功能强大
    3. 社区活跃，文档完善
    JMS是java提供的一套消息服务API标准，是java语言专属的消息服务标准，它在api层定义标准，并且只能用于java应用；二AMQP是在协议层定义的标准，是跨语言的
   ```
---
### 工作原理 
1. 基本结构  
   ```
   1. 生产者和mq建立连接，然后发送给消息MQ，消费者监听队列消息，然后消费消息。
   
   2. 组成部分说明：
      * broker:消息队列服务进程，此进程包括两个进程：Exchange和Queue
      * Exchange：消息队列交换机，按照一定的规则将消息路由转发到某个队列，对消息今次那个过滤
      * Queue：消息队列，存储消息的队列，消磁到达队列并转发给指定的消费方
      * producer :消息生产者，既生产方客户端，生产方客户端将消息发动到MQ
      * consuner:消息消费者，既消息方客户端，接受MQ转发的消磁
   
   消磁发布接受流程
   3. 消息发布
       1.生产者和Broker建立TCP连接
       2.生产者和Broker建立通道
       3.生产者通过通道消息发送Broker，有Exchange将消息进行转发
       4.Exchange将消息转发到指定的Queue(队列)
       5.关闭通道和连接【可能】
   
   4. 接受消息
       1.消费者和broker建立TCP连接
       2.消费者和broker建立通道
       3.消费者监听指定的queue
       4.当有消息到达queue是broker默认将消息推送给消费者
       5.消费者接受到消息进行消费
   ```
---
### 简单实例
1. 生产者 的代码
    ```
    1. 连接工厂：ip 端口5672  用户名  密码  设置虚拟机
   
    2. 创建通道，所有的消息都在通道中传输
   
    3. 声明队列 queueDeclare(String queue,boolean durable,boolean exclusive , boolean autoDelete， Map<String,Object> arguments)
       1.queue:队列名称
       2.durable：是否持久化，如果持久化，重启MQ队列任然存在
       3.exclusive：是否独占连接，队列只允许在该链接中访问。设置true ，connection连接关系队列自动删除，可用于创建临时队列
       4.autoDelete:自动删除，队列在不使用的情况下是否自动删除。将此参数和exclusive都设置为true，可以实现临时队列（队列不用自动删除）
       5.argument：设置队列的扩展参数：比如这种存活时间
   
   4. 指定交换机【如果不指定，则使用默认交换机】
   
   5. 发送消息basicPublish(String exchange ,String routingKey ,BasicProperties props ,byte[] body)
       1. exchange:交换机名称；如果不指定设置为，使用默认交换机，设置为  ""
       2. routingKey：路由key，交换机根据路由key将消息转发到指定的交换机。如果使用默认交换机，则将路由key设置为队列名
       3. props：消息属性
       4. body：消息内容
   ```
2. 消费者流程  
    ```
    1.创建通道
    2.声明队列【生产者，消费者都声明队列|交换机{如果不存在就创建}，则二者启动没有先后顺序】
    3.实现消费方法
           1现消费方法
           DefaultConsuner defaultConsuner = new DefaultConsuner (channel){
           当接收到消息后此方法将被调用
               * @paran consunerTag 消费者标签,用来标识消费者的,在监听队列时设置channel. basicConsune
               * @paran envelope信封,通过envelope
               * @paran properties消息属性
               * @paran body 消息内容
           @Override
           public void handleDelivery(String consumerTag, Envelope envelope, AMQP. BasicProperties properties, byte[] body) throws
           //交换机        
           String exchange = envelope. getExchange()
           //消息id, nq在charnel中用来标识消息的id,可用于确认消息已接收
           long deliveryTag = envelope. getDeliveryTag();
    4.监听队列：basicConsume (String queue, boolean autodck, Consumer callback)
       *1. queue 队列名称
       *2. autodck 自动回复,当消费者接收到消息后要告诉aq消息已接收,如果将此参教设置为tru表示会自动回复nq,如果设置为false要通过编程实现回复
       *3. callback,消费方法,当消费者接收到消息要执行的方法,监听队列后，回调方法进行消费
   
   5.在消费者中不关闭连接，因为消费者要一直监听 
    ```
3. 发送流程总结
    ```
    1、发送端操作流程
        1)创建连接
        2)创建通道
        3)声明队列
        4)发送消息
   
    2、接收端
        1)创建连接
        2)创建通道
        3)声名队列
        4)监听队列
        5)接收消息
        6) ack回复
    ```
---
### rabbitmq的工作模式

1. works queue 工作队列模式
    ```
    1.它的一个生产者将消息发给一个队列,多个消费者共同监听一个队列的消息，消费者之间不会消费同一条数据。
    2.rabbit采用轮询的方式将消息是平均发送给消费者,消息不会被重复消费
    3.队列中的每条消息只能由一个消费者消费  ###发布订阅区别
    使用场景多个消费者处理相同个任务
    ```
2. 发布订阅模式  fanout
    ```
    发布订阅模式：
    1、一个生产者将消息发给交换机
    2、与交换机绑定的有多个队列,每个消费者监听自己的队列。
    3、生产者将消息发给交换机,由交换机将消息转发到绑定此交换机的每个队列,每个绑定交换机的队列都将接收到消息。
    4. 每条消息可以由多个消费者共同消费  ###可以实现工作队列功能，但是比工作队列模式强大
   使用场景：一个超时案件需要短信发送和邮箱发送
    ```
   3. publish/subscribe与work queues有什么区别?
    ```
    1. publish/subscribe可以定义一个交换机绑定多个队列,一个消息可以发送给多个队列。
    2. work queues无需定义交换机,一个消息一次只能发送给一个队列。 但是发布订阅模式需要绑定交换机和队列 
    3. publish/subscribettwork queues的功能更强大, publish/subcribe也可以将多个消费者监听同一个队列实现work queues的功能。
    ```
   4. 发布订阅中注意点
    ```
   1.声明队列  【队列名称  是否持久化  是否生产者独占 是否自动删除】
   2. 声明交换机 【声明交换机名称   类型】
    进行交换机和队列练定
    参数: String queue, String exchange, String routingRey/*
    *参数明细:
    *1、 queue队列名称
    *2. exchange交换机名称
    * 3, routingkey路由key,在发布订阅模式中调协为空字符串  ### 在发布订阅模式中不需要写routingkey,写一个空字符串。  
     channel. queueBind(QUEUE INFORI EMAIL, EXCHANGE FANOUT-INFORM,""):
    ```
    5. 应用场景
     ```
        多个服务消费同一条消息，例如同时发送邮件和短息，就可以使用
     ```

5. Routing  路由模式 direct
   1. 原理
     ```
      路由模式:
      1、一个交换机绑定多个队列,每个队列设置routingkey ,并且一个队列可以设置多个routingKey.
      2、每个消费者监听自己的队列
      3、生产者将消息发给交换机,发送消息时需要指定routingKey的值,交换机来判断该routingkey的值和哪个队列的routingkey相等,如果相等则将消息转发给该队列。
     ```
   2. Routing模式和Publish/subscibe的区别?
      ```
      1. Publish/subscibe模式在绑定交换机时不需要指定routingkey ,消息会发送到每个绑定交换机的队列。
      2. Routing模式要求队列在绑定交换机时要指定routingkey (这就是队列routingkey ) ,发送消息将消息发送到和routingkey的值相等的队列中。
         每个队列可以指定多个routingkey ,如果发送消息时指定routingKey为"error",由于C1和c2的routingkey都是error ,所以消息发送给了C1和C2.如果发送消息时指定routingKey为"info",则只有C2可以接收到消息。
      3.Routing模式更加强大,它也可以实现Publish/subscibe的功能。
      ```
   3.   routing模式代码编写注意
      ```
      1. 消息发送
          1. 声明交换机：交换机类型 direct
          2. 绑定交换机  ：指定交换机名称  队列名称   routingkey
          3. 发送消息  ： 指定交换机名   routingkey   消息属性  消息体
      
      2. 消息接受
          1. 声明交换机：交换机类型 direct
          2. 绑定交换机  ：指定交换机名称  队列名称   routingkey
          3. 监听队列不变： 队列名称   自动回复  消费方法
      ```

6. Topics  
    1. topics说明
      ```
      路由模式:
      1、一个交换机可以绑定多个队列,每个队列可以设置一个或多个带统配符的routingkey.
      2、生产者将消息发给交换机,交换机根据routingkey的值来匹配队列,匹配时采用统配符方式,匹配成功的将消息转发到指定的队列。
     ```
    2. Topics与Routing的区别?
      ```
     Topics 交换机和队列绑定，指定了匹配的通配符，在消息发送时，指定交换机和routingkey,routingkey和通配符进行匹配
     fanout：等值匹配  
   
     1.Topics和Routing的基本原理相同,即:生产者将消息发给交换机,交换机根据routingKey将消息转发给与routingKey匹配的队列。
     2.不同之处是: routingKey的匹配方式, Routing模式是相等匹配, topics模式是统配符匹配。
     3.符号#:匹配一个或者多个词,比如inform.#可以匹配inform.sms, inform.email, inform.email. sms
       符号*:只能匹配一个词,比如inform.*可以匹配inform. sms, inform.email
      ```

7. headers  
   1. 介绍
     ```
      1. header模式与routing不同的地方在于, header模式取消routingkey ,使用header中的key/value (键值对)匹配队列。
      案例:
      根据用户的通知设置去通知用户,设置接收Email的用户只接收Email ,设置接收sms的用户只接收sms ,设置两种通知类型都接收的则两种通知都有效。
    ```
   2. 代码
    ```
      1. 队列与交换机绑定的代码与之前不同,如下:
      
          Map<String, Object> headers_email = new Hashtable<string, object>().headers_email.put("inform_email", "email");
          Map<String, Object> headers_sms = new Hashtable<String, object>();headers_sms. put("inform sms", "sms")
          channel. queueBind (QUEUE_INFORM EMAIL, EXCHANGE HEADERS INFORM, "",headers_email);  //在绑定队列的时候不指定routingkey,传入key/value即可
          channel. queueBind(QUEUE INFORM SMS, EXCHANGE HEADERS INFORM, "", headers_sms);
      
      2. 通知:1
      
          string message = "email inform to user"+i;
          Map<String,object> headers = new Hashtable<String, Object>();
          headers.put("inform-email", "email");//匹配email通知消费者绑定的header
          //headers.put ("inform-sms", "sms");
           //匹配sms通知消费者绑定的
          headerAMOP. BasicProperties. Builder properties = new AMOP. BasicProperties.Builder();properties.headers (headers);
          //Email通知
          channel.basicPublish (EXCHANGE_HEADERS_INFORM, "", properties.build(), message.getBytes());
    ```

8. RPC 
   1. 介绍  
     ```
      RPC即客户端远程调用服务端的方法,使用MQ可以实现RPC的异步调用,基于Direct【订阅发布模式】交换机实现,流程如下:
        1、客户端即是生产者就是消费者,向RPC请求队列发送RPC调用消息,同时监听RPC响应队列。
        2、服务端监听RPC请求队列的消息,收到消息后执行服务端的方法,得到方法返回的结果
        3、服务端将RPC方法的结果发送到RPC响应队列 
    用自己的话解释
    ```
---
###消息丢失：
1. rabbitmq的拦截功能 如何实现？  


2. 自增序列如何生成，如何保证线程安全，真实的实现？ 
 
3. 如何验证有序性，序列化如何加到消息中的，以什么方式加入的？  

4. AMQP 协议
* 为什么使用消息队列  
```
消息队列的本质：是一种先进先出的数据结果
作用：两个系统之间数据传递
使用场景：解耦，异步，肖峰
         解耦：下游系统服务异常，上游系统是无感知的。例如上游服务将消息发送到消息队列，如果下游系统异常，无法消费，这个时候消息是缓存在消息队列中，重启邮件服务重新消费，对其他的服务不会造成影响。
```

* 消息队列选择  
1. rabbitmq :erlang语言编写，开源社区活跃，比较稳定的支持，如果不考虑二次开发推荐使用
2. rocketmq：开发语言java，接受阿里高并发业务考研，稳定和性能不错，考虑二次开发，推荐使用
3.kafka：大数据领域实时计算，入职采集，社区活跃度高，推荐使用  

* 系统可用性降低  
引入外部依赖越多，系统稳定性越差：集群解决

* 系统复杂度提高  
1. 消息丢失
   1. 原因：  
      1. 生产者的消息无法送达消息队列
      2. rabbitmq宕机
      3. 消费者没有将消息消费掉，但是MQ在消息消费后删除
   2. 解决  
      1. 开启消息确认confirm，生产者发送MQ消息后，返回确认消息，如果没有返回则继续发送
      2. MQ宕机，增加消息持久化  
      3. 消费者使用手动消息确认，在消息成功消费后返回确认消息  
---
### 消息传递的顺序性

---
## 消息数据处理一致性  
部分服务消费失败，导致服务之间的数据不一致，可以通过分布式事务处理

---
### 消息丢失  
  1. 消息丢失原因   
        ```
          发送方  、MQ 、消费方可能导致消息丢失
        ```
  2. 保证消息不丢失  
      ```
        1. 发送方可靠接受：使用rabbitmq的confirm机制，在发送方将消息发送给消息队列后，得到确认后，结束一次消息发送
        2. MQ进行消息持久化  ：在声明队列是设置他的持久化属性为true，队列消息会存储在磁盘中，mq宕机重启后将消息加载
        3. 消费者监听队列 ，消费方消费完毕后进行手动ACK确认，MQ收到消费方ACk确认后再删除队列内存和持久化中的消息 。
     
     
     
     生产阶段：
     1.消息队列通过最常用的请求确认机制，来保证消息的可靠传递：当你的代码调用发消息方法时，消息队列的客户端会把消息发送到 Broker，Broker 收到消息后，会给客户端返回一个确认响应，表明消息已经收到了。客户端收到响应后，完成了一次正常消息的发送。
     2.Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失。有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会以返回值或者异常的方式告知用户。
     3.你在编写发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失
     	同步发送时，只要注意捕获异常即可
     	异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。
      
      存储阶段
      1.在存储阶段正常情况下，只要 Broker 在正常运行，就不会出现丢失消息的问题，但是如果 Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。
     2.如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。
     对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，将消息写入磁盘后再给 Producer 返回确认响应，这样即使发生宕机，由于消息已经被写入磁盘，就不会丢失消息，恢复后还可以继续消费
     如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成：至少将消息发送到 2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的 Broker 可以替代宕机的 Broker，也不会发生消息丢失
     
     消费阶段
     1.消费阶段采用和生产阶段类似的确认机制来保证消息的可靠传递，客户端从 Broker 拉取消息后，执行用户的消费业务逻辑，成功后，才会给 Broker 发送消费确认响应
     2.编写消费代码时需要注意的是，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认 
     ```
---
### 消息重复 

1. 消息重复的原因 
    ```
    1.外部原因：因为网络原因消息不可达
    2. 内部原因：从消息队列机制：必然存在重复消息
         消息队列提供三种传递消息时能够提供的服务质量标准，这三种服务质量从低到高依次是：
            1.At most once: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用。例如：每分钟上报一次车辆轨迹，可以接受轨迹的少部分缺失
            2.At least once: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。
            3.Exactly once：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。
    3.消费时消息重复
       在消费者消费场景下，消息已经投递到消费者处理，当消费方个MQ反馈应答时网络闪断。为了保证消费至少被消费一次，MQ将在网络恢复后再次尝试投递之前已经被消费方处理的消息，此时消费者收到两条内容相同的消息。
   ```
2. 解决方案：消息幂等
   1. 使用数据库唯一性约束实现 
   ```
   一、 创建一张记录消息的消费记录表
          1,将具有唯一标识的一个或多个字段作为唯一索引
          2.如果消息已经消费，由于唯一约束特性无法插入，则无法消费，丢失重负消息。
   二、. 为更新的数据设置前置条件
            1. 为更新的数据设置前置条件【类似并发编程中的CAS原理，在更新数据前比较当前值和内存值，是否相等，如果不相等就停止更新。认为该操作已经完成】
            2. 另外一种实现幂等的思路：给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据
                 将账户 X 的余额增加 100 元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果账户 X 当前的余额为 500 元，将余额加 100 元”，这个操作就具备了幂等性。
                 对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。
    三、 乐观锁
           更加通用的前置判断条件：给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等更新       
   ```
3. 小结
    ```
    MQ消息的重复问题和幂等性问题
   -消息重复问题：网络不可达，不可避免
   
   -幂等性
   消息携带全局ID，消费方接收到后先查再处理，根据全局ID判断重复，则直接将消息丢弃
   ```
---
###消息积压  【收发两端的性能优化】

1. 收发两端性能优化
    ```
   1. 消息队列本身的处理能力要远大于业务系统的处理能力,一般消息队列不是性能的瓶颈。对于性能的优化重点在消息收发两端。
   
   ```

2. 消息发送端性能优化：【消息发送性能低下】
    ```
     一、 发送端性能优化
      1.代码发送消息的性能上不去，优先检查一下，发消息之前的业务逻辑耗时太多导致的对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能
      2.无论是增加每次发送消息的批量大小，还是增加并发，都能成倍地提升发送性能。至于到底是选择批量发送还是增加并发，主要取决于发送端程序的业务性质
      消息发送端是一个微服务，主要接受请求处理在线业务。微服务在处理每次请求的时候，就在当前线程直接发送消息就可以了。并且在线业务比较在意的是请求响应时延，选择批量发送必然会影响 RPC 服务的时延。
      这种情况，需要通过并发来提升发送性能。增加并发方式：1.通过水平扩容 2.增加单个服务的并发处理能力
      
      
   ```
3. 消息接收端优化：【消息积压】
    ```
    一、 消费端性能优化 
     1.使用消息队列，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压，。如果这种性能倒挂的问题只是暂时的，那问题不大。要是消费速度一直比生产速度慢，时间长了，整个系统就会出现问题，要么，消息队列的存储被填满无法提供服务，要么消息丢失，这对于整个系统来说都是严重故障。
     2.一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行
     3.消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。
     特别需要注意的一点是，在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的
     
   消息队列的健康使用状态，消费端性能比生产端性能高，才不会造成消息积压。
   提高消费端性能：1. 优化业务逻辑 2. 增加消费者，利用rabbitmq多个消费者监控一个，多个消费者轮训消费队列，这是工作队列模式。
   ```
4. 如何发现消息积压，消息积压出现的位置
    ```
     1.消息队列一般都有监控，可以通过监控发现到底是哪一个消费端慢
     2.有一种不太常见的情况，你通过监控发现，无论是发送消息的速度还是消费消息的速度和原来都没什么变化，这时候你需要检查一下你的消费端，是不是消费失败导致的一条消息反复消费这种情况比较多，这种情况也会拖慢整个系统的消费速度。
     3.如果监控到消费变慢了，你需要检查你的消费实例，分析一下是什么原因导致消费变慢。优先检查一下日志是否有大量的消费错误，如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在什么地方不动了，比如触发了死锁或者卡在等待某些资源上了
    ```
---
### 消息顺序性问题

1. 什么是消息顺序消费； 
    ```
    1. 消息有序指的是可以按照消息的发送顺序来消费。
    2. 一个订单产生3条消息，分别 订单创建、订单付款、订单完成，消费式，按照顺序依次消费才有意义。同时，多个订单之间有时可以并行消费。
   ```


2. 确保消息顺序消费方案？
    ```
      1. Producer同步发送
          对于需要有序的消息：
           需要选择同一个queue，因为RocketMQ只保证queue的局部有序，无法保证topic的消息有序。
           需要等待上一个发送成功，收到成功的回复后，才可以发送下一个。
      2. 消费者：
           消费者监控指定的队列，顺序消费
      
   模型：RocketMQ只保证queue的局部有序，无法保证topic的整体的消息有序。
         1. 生产者发送消息：使用confirm机制，发送消息后，需要等收到成功的回复后，才发下一条数据。
         1. 生产者根据消费ID将同一组消息发送到一个Queue
         2. 多个消费者同时获取Queue中的消息消费。
         3. MQ使用分段锁保证单个Queue中的有序性
   
   保证消息的消费顺序
   （1）rabbitmq
   ①拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。
   
   作者：一条路上的咸鱼
   链接：https://www.jianshu.com/p/02fdcb9e8784
   来源：简书
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    ```
---
### 端口
```
5672 --client端通信口
15672 -- 管理界面ui端口
25672 -- server间内部通信口
```