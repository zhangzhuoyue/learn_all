### hashmap 

---
### 初始容量为什么是2的指数幂
1. h & (length  - 1)  等价于 hash % 容量，前提条件是容量是2 的指数次幂
2. 使用原因：& 运算是二进制运算；取模运算会转化二进制运算，中间有一个转化的过程。所以& 运算效率高。后续操作 例如在扩容是也要用到容量是2 的指数次幂这个特性
3. 在java7 put操作 以及 扩容迁移rehash都会计算hash，使用效率更高的&更合理
4. length -1 
    ```
   1. 16 -1 的二进制1111 ，hash &（length-1）的范围在0-15 ，结果范围有length-1决定。
   2. 与运算存在的问题：只有hash的低16位参与运算，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重，如果最后几个低位呈现规律性重复，就无比蛋疼。
   3. 解决这个问题引入扰动函数：将高16位和低16位进行异或运算。混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
   ```
---
### 加载因此为什么是0.75
1. 负载因子表示对容量的使用率，当达到容量的0.75进行2倍的扩容。
2. 为什么不是1 或者 0.5  ；如果是1 则完全的使用容量空间，因为hash碰撞的原因数据并不是均匀分布，造成java7 中的链表过长，以及java8 中红黑树的频繁自旋，使得put的时间增加。
    如果是0.5 ， 那么每次达到容量的一半就进行扩容，默认容量是16， 达到8就扩容成32，达到16就扩容成64， 最终使用空间和未使用空间的差值会逐渐增加，空间利用率低下
3. 0.75  实在1 和0.5 的中间值，作为一个对空间可时间的均衡。

4. 与0.75 相关的是java8 中链表程度 >= 8转换为红黑树
    1. 查询效率：链表的时间复杂的 O(n)  ,红黑树的时间复杂度O(lgn) 转换后查询效率提高，在put操作和get操作都可以
    2. 在 负载因此是0.75 情况下，根据泊松分布：长度为length的数组中hash地放入0.75*length数量的数据，数组中某一个下标放入8个数据的概率 位千万分之六。
    3. 由上面的分析可以看出，在负载因子是0.75的情况下，数组下标中的链表的元素个数达到8的概率很小，因此这种红黑树的转换并不长发生。

---
### 链表长度大于等于8转化为红黑树？

1. 理解泊松分布
    ```
   1.泊松分布是最重要的离散分布之一，它多出现在表示在一定空间内出现的事件个数这种场合。对应到hashmap就是key存储在同一个桶的个数。
   ```
2. 为什么存在红黑树转换
    ```
   1. 从时间复杂度分析，链表的时间复杂度O(n),红黑树的时间复杂度O(lgn)。
   2. 在链表过过长，影响put和get时间
   ```
3. 触发红黑树转化的条件
    ```
   1. 同一个桶中的链表节点数 >= 8 时触发转换。
   2.同时发生这种转换的概率很低，因为在负载因此为0.75的情况下，泊松分布计算得出8 个元素hash值相同的概率是千万分之六。
   ```

---
### put 操作造成的扩容问题：链表死循环 | rehash问题
     1. 计算hash值，根据 & 运算计算出数组下标，如果较链表中key有相同的，如果有则将key的oldvalue替换成newvalue，然后返回oldValue
     2. 如果key不存在，然后在进行数据添加是，比较当前数组元素个数是否 > = 数组容量 * 负载因子 && 当前数组下标的是否有数据；当这两个条件都满足则进行扩容。
     3. 在扩容过程中，会涉及rehash，所以使用2的次幂是有必要的。在数组扩容会涉及到死锁和链表环
 
* java 7 扩容死锁演示与环链形成分析
     1. 扩容之后，需要将老的数组转移到新的数组当中去，在这个过程中会出现问题：死锁和链表环
     2. java 7 链表环发生在多线程同时put 进而引发的链表环问题
         ```
        1. 线程A 和线程B同时数据迁移，其中线程A 已经获取获取链表中的元素指正，这时失去CPU执行权，处于休眠状态。线程B进行数据迁移。
        2. 在理解数据迁移的过程中首先明白，jdk1.7中链表插入是表尾插入。在进行数据迁移是表头插入，为什么使用 的插入法不同
            a. java 7 在put操作 需要判断key在一个桶中是否有重复，这个需要遍历链表，遍历完链表后到达链表尾部，这个时候讲节点插入尾部是合理的。
            b. 当数组扩容后，需要进行数据迁移，这个时候不在需要判断key的重复问题，自然使用表头插入。
            c. 插入的顺序和数据迁移的顺序相反，造成迁移后的链表数据顺序和原来的相反。这个时候线程 A 再拿着旧的链表指针迁移新的链表造成链表环的问题，死循环的问题。
         
        ```

* java 8 如何解决环链，以及rehash问题【使用高低位四个指针】
    1. java 8 的解决方案： 使用四个高低位节点
        ```
        1. 低位头指针  低位尾指针   高位头指针  高位尾指针
       2. e.hash & oldCap == 0  低位 ，低位的节点在扩容后的数据迁移不需要改变所在的数组下标  ；e.hash & oldCap == 0 高位，节点在扩容后的数据迁移所在的下标 j+newCap;
           迁移后的下标为什么这样确定？
               1. 如果是低位，则扩容后hash & (length -1) 不变，
               2. 如果是高位，则扩容后hash & (length - 1) 等价于 j + oldCap
               3. 原因在于：hash * oldCap 中，例如原来的容量16 ，他的二进制为10000 ；扩容后容量是32 ，二进制100000，他的length - 1的二进制11111；如果hash * oldCap =0,则说明该key的hash在新的容量中计算下标length -1位0。
       
       3. 将链表分成高低位两部分，低位所在数组下标不变，高位的数组下标位oldCap + j[加的原因在于length -1 ]最高位表示的十进制数是oldCap，其余位二进制转换为十进制就为原数组下标。
       4. java 8中不需要rehash 已经链表的节点的颠倒。巧妙的方式提高了hashmap的put效率，解决了链表死循环问题。
        ```
 ---
 ### ConcurrentHahMap 线程安全吗，什么是分段锁
 
 
 
 
 
 
 
 
 
 
 
 ---
 ### 红黑树
 
 
 ---
 ### 链表
 