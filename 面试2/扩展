## 扩展

---
### 数据库优化

1. 定位执行效率低的SQL
    ```
   1. 慢查询日志
      1. show variables like '%slow_query_log%';查询慢日志信息，是否开启，日志位置
      2. 开启慢查询日志 set global slow_query_log=1;
      3. 慢查询日志记录的慢SQl的条件：默认情况下long_query_time的值为10秒，可以使用命令修改，也可以在my.cnf参数里面修改。关于运行时间正好等于long_query_time的情况，并不会被记录下来
      4. 分析慢查询日志：MySQL提供了日志分析工具mysqldumpslow ，查看mysqldumpslow的帮助信息
                   -s, 是表示按照何种方式排序
                       c: 访问计数
                       l: 锁定时间
                       r: 返回记录
                       t: 查询时间
                       al:平均锁定时间
                       ar:平均返回记录数
   
   
   ```
    
1. IO优化
    1. TOP监控命令
    ```
   1.  top 命令
   top 命令通过查看 CPU 的 wa% 值来判断当前磁盘 IO 性能，如果这个数值过大，很可能是磁盘 IO 太高了，当然也可能是其他原因，例如网络 IO 过高等。
   wa：cpu等待磁盘写入完成时间
   
   2. 如果一台机器看到wa特别高，那么一般说明是磁盘IO出现问题，可以使用iostat等命令继续进行详细分析。
   
   3. sar 命令是分析系统瓶颈的神器，可以用来查看 CPU 、内存、磁盘、网络等性能。
      sar 命令查看当前磁盘性能的命令为：sar -d -p 1 2;
   
       await：平均每次设备 I/O 操作的等待时间（以毫秒为单位）。 
       svctm：平均每次设备 I/O 操作的服务时间（以毫秒为单位）。
       
       对于磁盘 IO 性能，一般有如下评判标准：
           1. 正常情况下 svctm 应该是小于 await 值的，而 svctm 的大小和磁盘性能有关，CPU 、内存的负荷也会对 svctm 值造成影响，过多的请求也会间接的导致 svctm 值的增加。
           2. await 值的大小一般取决与 svctm 的值和 I/O 队列长度以 及I/O 请求模式，如果 svctm 的值与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，如果 await 的值远高于 svctm 的值，则表示 I/O 队列等待太长，系统上运行的应用程序将变慢，此时可以通过更换更快的硬盘来解决问题。
   
   4. innodb参数 ： 就用两个新的参数，即innodb_read_io_threads和innodb_write_io_threads，取代了innodb_file_io_threads如此调整后，在Linux平台上就可以根据CPU核数来更改相应的参数值了，默认是4。
      
      假如CPU是2颗8核的，那么可以设置：
      innodb_read_io_threads = 8
      innodb_write_io_threads = 8
      
      如果数据库的读操作比写操作多，那么可以设置：
      innodb_read_io_threads = 10
      innodb_write_io_threads = 6
       原文链接：https://blog.csdn.net/MaueiceWei999/article/details/88403069
   
   ```
3. Druid来配置监控发现慢SQL
    1. 配置文件开启监控
    2. 继承 StatViewServlet ：
       这个StatViewServlet的用途包括：
           1. 提供监控信息展示的html页面
           2. 提供监控信息的JSON API

4. Tomcat 作为Servlet容器,负责处理客户请求,把请求传送给Servlet,并将Servlet的响应传送回给客户.Servlet最常见的用途是扩展Java Web服务器功能,提供非常安全的,可移植的,易于使用的CGI替代品.

5. 在web.xml中配置MyServlet，为什么需要配置？让浏览器发出的请求知道到达哪个servlet，也就是让tomcat将封装好的request找到对应的servlet让其使用。

6. @WebServlet : 该注解的作用等价于 在web.xml中配置的该servlet的<servlet-mapping>元素中<url-pattern>的配置,进行拦截
---
### 数据库分库分表

1. 没有做过，可以说我有两个思路：1. 分库分表 2.微服务，每个服务对应一个数据库，如果有瓶颈就设置主从

2. 分库分表
    


---
### 分表后如何做统计操作

---
### 分库分表后的事务操作

1. [InnoDB对分布式事务的支持](https://blog.csdn.net/u011156496/article/details/88636026)
   1. InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。
   2. XA事务语允许不同数据库之间的分布式事务，如一台服务器是MySQL数据库的，另一台是Oracle数据库的，又可能还有一台服务器是SQL Server数据库的，只要参与在全局事务中的每个节点都支持XA事务。
   3. 微服务都有自己的数据库，在这种情况下，一定需要使用分布式事务来保证数据的安全
      1. 如果发生的操作不能全部提交或回滚，那么任何一个节点出现问题都会导致严重的结果。
      2. 可见与本地事务不同的是，分布式事务需要多一次的PREPARE操作，待收到所有节点的同意信息后，再进行COMMIT或是ROLLBACK操作。
      3. TCC框架
      4. 两阶段提交的弊端：
         ```
         1. 不过但凡使用过的上述两阶段提交的同学都可以发现性能实在是太差，根本不适合高并发的系统。为什么？
            两阶段提交涉及多次节点间的网络通信，通信时间太长！
         2.  事务时间相对于变长了，锁定的资源的时间也变长了，造成资源等待时间也增加好多！
         3. 正是由于分布式事务存在很严重的性能问题，大部分高并发服务都在避免使用，往往通过其他途径来解决数据一致性问题。比如使用消息队列来避免分布式事务。
         ```
2. 分布式事务 CAP  base理论笔记

3. sharding-jdbc介绍
    ```
   1. 开发者需要把单体应用拆分为多个独立的小应用，把单个数据库按照分片规则拆分为多个库和多个表。
   2. 数据拆分后，如何在多个数据库节点间保证本地事务的ACID特性则成为一个技术难题，并且由此而衍生出了CAP和BASE经典理论。
   CAP    
       1. CAP理论指出，对于分布式的应用而言，不可能同时满足C（一致性），A（可用性），P（分区容错性），由于网络分区是分布式应用的基本要素，因此开发者需要在C和A上做出平衡。
   BASE
       1. 由于C和A互斥性，其权衡的结果就是BASE理论。
       2. BASE理论的定义看笔记
       3. 对于大部分的分布式应用而言，只要数据在规定的时间内达到最终一致性即可。我们可以把符合传统的ACID叫做刚性事务，把满足BASE理论的最终一致性事务叫做柔性事务。
   ```





         
---
### [hashmap遍历](https://www.cnblogs.com/Bkxk/p/11063720.html)

---
### nginx

















