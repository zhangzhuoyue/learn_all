## 设计模式在项目中的应用  

24.单例模式在项目中：一个全局线程池  
25.简单工厂和出现工厂的区别
---
### 简单工厂

1. 基本介绍
   ```
   1)简单工厂模式是属于创建型模式,是工厂模式的一种。简单工厂模式是由一不工厂对象决定创建出哪一种产品类的实M,简单工厂模式是工广模式家族中最简单实用的模式
   2)简单工广模式:定义了一个创建对象的类,由这个类 封装实例化对象的行为(代码)
   3)在软件开发中,当我们会用到大量的创建某种、某类或者某批对象时,就会使用到工广模式.
   ```
   

1. 优缺点
    ```
   传统的方式的优缺点
   1)优点是比较好理解,简单易操作。
   2)缺点是违反了设计模式的ocp原则,即对扩展开放,对修改关闭。即当我们给类增加新功能时候,尽量不修改代码,或者尽可能少修改代
   3)比如我们这时要新增加一个Pizza的种类(Cheese披萨),我们需要做如下修改.
   ```


---
### 工厂方法模式

1. 模式定义
    ```
   模式定义
   定义一个用于创建对象的接口,让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟(目的:解耦,手段：虚函数)到子类。

   ```

1. 工厂方法模式概念
    ```
   1 "对象创建”模式
       1. 通过“对象创建”模式绕开new,来避免对象创建(new)过程中所导致的紧耦合(依赖具体类) ,从而支持对象创建的稳定。它是接口抽象之后的第一步工作。
       2. 典型模式Factory MethodAbstract FactoryPrototypeBuilder
   ```

2. 要点总结  
    ```
   1. Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系,面对一个经常变的 k型,紧 合关系(new)导致软件的脆弱。
   2. Factory Method模式通过面向对象的手法,将所要创建的具体对象工作延迟到子类,从而实现一种扩展)(而非更改)的策略,较好地解决了这种紧耦合关系。
   3. Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。
   
   ```

3. 自己的话
    ```
   设计模式就是讲变化的部分隔离，项使用者提供稳定不变的部分，避免紧耦合造成面对变化时代码的脆弱。
   ```
---
### 抽象工厂方法模式

1. 工厂方法模式和抽象工厂解决的是同一类问题，但是有细微的不同
    ```
   抽象工厂模式
   1. 在软件系统中,经常面临着“一系列相互依赖的对象”的创建工作;同时,由于需求的变化,往往存在更多系列对象的创建工作。
   2. 如何应对这种变化?如何绕过常规的对象创建方法(new),提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作"的紧耦合？
   ```
2. 模式定义
   ```
   提供一个接口,让该接口负责创建一系列“相关或者相互依赖的对象",无需指定它们具体的类。
   ```
   
3. 设计模式优缺点
    ```
   1.任何一个模式都有缺点，设计模式问题的部分就是他的缺点。如果稳定的部分变化了，那么这个模式就不适用，
   2. 设计模式解决的是稳定中有变化的额问题，这是常态。从极端角度来说，所有状态都变化，所有的状态搜不变，那就不需要使用设计模式。
   ```
4. 工厂方法模式是抽象工厂的特例
    ```
   1. 抽象工厂中有多个工厂创建，工厂方法中只有一个工厂创建
   ```

5. 要点总结
    ```
   要点总结
   1. 如果没有应对"多系列对象构建”的需求变化,则没有必要使用Abstract Factory模式,这时候使用简单的工广完全可以。
   2. “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。
   3. Abstract Factory模式主要在于应对"新系列"的需求变动。其缺点在于难以应对"新对象"的需求变动。
   ```

6. 案例
    ```
   1.创建mysql连接对象
   2. 创建 命令对象
   3. 创建执行对象
   这是有依赖关系的，使用抽象工厂
   ```

---
## 单例模式

1. 动机(Motivation)
    ```
    1.在软件系统中,经常有这样一些特殊的类,必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。
    2.如何绕过常规的构造器,提供一种机制来保证一个类只有一个实例?
    3.这应该是类设计者的责任,而不是使用者的责任。
   ```
2. 双重检索的reorder问题  [懒汉式]
    ```
   1.reorder问题是有处理器优化引起的，编程语言本身无法解决。
   2.java提供了volatile【内存屏障指令解决】。
   ```

3. 饿汉式(静态常量)
    ```
   优缺点说明:
      1)优点:这种写法比较简单,就是在类装载小时候就完成实例化。避免了线程同步问题。
      2)缺点:在类装载的时候就完成实例化,没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例,则会造成内存的浪费
      3)这种方式基于classloder机制避免了多线程的同步问题不过, instance在类装载时就实例化,在单例模式中大多数都是调用getinstance方法, 但是导致类装载的原因有很多种,因此不能确定有其他的方式(或者其他的静态方法)导致类装载,这时候初始化instance就没有达到lazy loading的效果
      4)结论:这种单例模式可用,可能造成内存浪费
   ```
4. 静态内部类实例
    ```
   class singleton{
       private Singleton() { }
       private static class SingletonInstance {
           private static final SingLeton INSTANCE = new Singleton();
       }
       public static Singleton getInstance() {
          return SingletonInstance. INSTANCE:
       }
   }
   ```






































