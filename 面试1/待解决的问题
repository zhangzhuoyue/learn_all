* ==  equals的区别  
```

==是判断两个变量或实例是不是指向同一个内存空间，
equals是判断两个变量或实例所指向的内存空间的值是不是相同  

==是指对内存地址进行比较   
基本数据类型是存储在栈内存中，相同的数据，他的内存地址形同，因此基本数据类型使用==可以判断是否相等

equals是object方法，内部实现是两个对象进行==比较，然后在String中重写，如果==地址相同，相等，否则比较元素值
```
* 在一个实体中创建一个年龄用什么数据类型，int integer 对于数据库的区别 已经在使用以及初始化的区别

    
* 接口幂等 ，客户端 token 只能调用一次的区别  
```
1. 概念：不管做多少次，都应该产生一样的效果或返回一样的结果
2. 幂等方案：
   a. 查询操作
   b. 删除操作
   c. 唯一索引，防止新增脏数据
   d. token机制，防止页面重复提交;业务要求： 页面的数据只能被点击提交一次；发生原因： 由于重复点击或者网络重发
       处理流程：1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间；
                2. 提交后后台校验token，同时删除token，生成新的token返回。
                   token特点：要申请，一次有效性，可以限流。
                   注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用；
   e. 乐观锁——乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。
      乐观锁的实现方式：乐观锁的实现方式多种多样可以通过version或者其他状态条件：1. 通过版本号实现update table_xxx set name=#name#
   
   g. 悲观锁——获取数据的时候加锁获取。select * from table_xxx where id='xxx' for update; 
      注意：id字段一定是主键或者唯一索引，不然是锁表
``` 


* 集群中定时任务，如何防止重复发送 
```
1. 利用数据库的共享锁事务管理机制来运行定时任务。 【适合小型项目】 
流程：
    java的Enumeration对象中有ip信息
   1.原理：在数据库中新建一张表定时任务表，存储了上次执行定时任务的ip地址（ip），任务名称（task_name)，是否正在执行（execute）
集群中的所有服务器都是走以下流程

第一步：查找数据库的定时任务表。

第二步：检查是否有机器在运行定时任务。检查方法：update定时任务表的excute字段为1（1为执行中，0为未执行）、ip为自己的ip，如果update失败，则证明有机器在执行该定时任务，该机器的定时任务就不执行了，成功则进行第三步。

第三步：执行定时任务的具体内容。

第四步：还原excute字段为0。

以上是该方案的流程，利用了mysql的共享锁机制判断，通过是否更新成功来判断是否有机器正在执行定时任务，这种方案可以保证任务只执行一次，且只要集群中有一台服务器是好的，就会执行任务。


```


* 设计模式在项目中的使用   ：单例模式  工厂模式  项目如何使用  已经使用场景  
```
1. 概念 ： 单例模式，顾名思义就是只有一个实例，并且她自己负责创建自己的对象，这个类提供了一种访问其唯一的对象的方式  
核心代码：构造方法私有化，private。 

懒汉模式
线程不安全，延迟初始化，严格意义上不是不是单例模式
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
  
    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}


饿汉模式
线程安全，比较常用，但容易产生垃圾，因为一开始就初始化

public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}

双重锁模式
线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。

public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  //单线程中存在有序性问题
        }  
        }  
    }  
    return singleton;  
    }  
}
双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题



静态内部类单例模式

public class Singleton { 
    private Singleton(){
    }
      public static Singleton getInstance(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 

1.只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。
2.在同一个类加载器下，一个类型只会被初始化一次

```
* 多线程中的线程池 中的参数  
```
1. corePoolSize    
表示线程池保有的最小线程数,线程池队列为空，线程池始终持有的线程数
allowCoreThreadTimeOut(boolean value)  核心线程超时也会回收
2. maximumPoolSize 

3. keepAliveTime & unit 
线程池的线程数大于 corePoolSize

4.  BlockingQueue<Runnable> workQueue   
线程池的任务消费速度 < 生产者生产速度  ，队列：肖峰 填谷

5. ThreadFactory threadFactory 
线程工厂  定义线程名称

6.RejectedExecutionHandler handler
拒绝策略 
1.AbortPolicy ，默认：默认的拒绝策略 直接拒绝任务抛出异常
2.DiscardPolicy   直接丢弃任务，没有任何异常抛出
```

* 需要有序但是不重复使用什么集合

```
LinkHashMap 
```

* 熔断和降级 
```
熔断VS降级
相同点：
    目标一致 都是从可用性和可靠性出发，为了防止系统崩溃；
    用户体验类似 最终都让用户体验到的是某些功能暂时不可用；

不同点：
    触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；
吞吐量（TPS）、QPS每秒查询率、并发数、响应时间（RT）概念

```

* 注册中心是保险公司的注册中心吗？ 如果独立项目，注册中心应该如何；为什么独立，独立的展示平台项目。   

* 加密算法
 ```
4.1. MD5算法
MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。

1.加密及解密类：  
  1.带秘钥加密生成密文
  2.密文验证  

//引用  java.security.MessageDigest公共类
//getInstance("MD5")方法 设置加密格式
//md5 = MessageDigest.getInstance("MD5");  //此句是核心

MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致


```     
* 排序算法 
```
1. 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
    1.交换排序：冒泡排序，快速排序
    2.插入排序：简单排序，希尔排序   
    3.选择排序：简单选择排序，堆排序
    4.归并排序：二路归并排序，多路归并排序
排序算法   时间复杂度    空间复杂度    稳定性 
插入排序    n^2                       稳定
快速排序    logn                      不稳定



2. 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。





``` 
* redis集群 持久化  缓存穿透  
```
缓存穿透：
1.缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。
2.数据在redis不存在，数据库也不存在，返回空，一般来说空值是不会写入redis的，如果反复请求同一条数据，那么则会发生缓存穿透。
缓存击穿：
缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就击穿缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

缓存雪崩
缓存雪崩是指，缓存层出现了错误，不能正常工作了。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。
```  

 * spring boot使用机制  
 ```

```
*  mysql单表最大存储数据 
几百万
```

```
    项目中的难点  
存储过程 触发器   前端框架      explain分析
索引数据结构    乐观锁  悲观锁    对于juc的整体介绍      get  post区别    

* mybatis的接口和mapping如何建立映射   接口无法直接使用  
```
使用动态代理完成，在代理中完成舍SQL的执行
```
* jvm 类加载机制   回收算法   项目中用了那个回收  jvm堆以及垃圾不同代  

```

```


     
发生oom如何定位分析  用什么工具
线程池  线程池运行一个任务流程
hashmap的原理
缓存穿透 缓存更新
* 消息中间件消息丢失  消息去重   消息拥堵  
```

```
*  linux操作  
```
1. 发包流程
  登录服务器
  进入到项目文件夹下  cd 命令
  搜索java进程 ps -ef | grep java 通过进程关键字查找进程； 通过端口号查看进程：netstat -anp | grep 3306 //查看所有3306端口使用情况   
  动态查看日志：tail -f app.log    搜索分页查看文件：more 文件名 | grep Error
  一种是手动发包，拉代码，打包，部署，查看进程是否部署成功
  
1.查看磁盘分区大小
netstat -anp | grep 3306 //查看所有3306端口使用情况
df -h
2.查看子文件大小
du -h    显示各个子目录的大小，由于目录过多，需要排序并且选择最大的几个目录
du -h /  | sort -rn | head -10

2.查看系统资源 top
第一行： 系统时间  + 系统运行时间 + 几个用户 + 1/5/15分钟系统平均负载

（2）第二行：进程总数(total) + 正在运行进程数(running) + 睡眠进程数(sleeping) + 停止的进程数(stopped)+ 僵尸进程数(zombie)

（3）第三行：用户空间CPU占比(us) + 内核空间CPU占比(sy)+ CPU空置率(id)
详细显示：进程id   cpu使用率    内存使用率    

M     大写M，按照内存占用率进行降序排序
P     大写P，按照CPU占用率进行降序排序
```
多线程 juc 线程池  总体介绍
分表
sql优化
io  接受文件
线程等待
可重读度解决的问题
ioc  aop源码分析
springboot启动机制 
es
redis集群  数据类型  持久化  缓存穿透

mysql一张表最大放多少数据
oracle最大放多少数据       对于大表查询优化，以及对于分库分表的思想

前端数据库取数  循环  jQuery
项目中遇到的问题，怎么解决的。
127461201705229181

mybatis中接口如何实现运行和数据库进行交互。



1. [软件的生命周期](https://www.cnblogs.com/liyongmei/p/10637274.html)
```
生命周期常见的有：瀑布模型、V模型、敏捷开发模型。

阶段：需求分析->软件设计->程序编码->软件测试->运行维护
1.1瀑布模型

瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，包括问题定义及规划、需求分析、软件设计、程序编码、软件测试和运行维护等六个基本活动，并且规定了他们自上而下，相互衔接的固定次序，形如瀑布流水，逐级下落，具有顺序性和依赖性，最终得到软件产品。

因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。

包括软件工程开发、企业项目开发、产品生产以及市场销售等构造瀑布模型。

每个阶段规定的文档需进行评审，评审完后才可以进入下一个阶段。

优点：

1）为项目提供按阶段划分的检查点

2）当前一阶段完成后，你只需要关注后一阶段

3）可在迭代模型中应用瀑布模型

4）提供一个模板，这个模板使得分析，设计，编码，测试和支持的方法可以在该模板下有一个共同的指导

缺点：

1）各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。

2）由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险。

3）通过过多的强制完成日期和里程碑来跟踪各个项目阶段。

4）瀑布模型的突出缺点是不适应用户需求的变化。
```


2.构造方法可以被重写吗
```
构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承。 

又由于构造器不能继承，所以就不能被重写。但是，在同一个类中，构造器是可以被重载的。

一，重载

1.概念：对于同一个类，如果这个类里面有两个或者多个重名的方法，但是方法的参数个数、类型、顺序至少有一个不一样，这时候局构成方法重载



二，重写

1.概念：

当一个子类继承一父类，而子类中的方法与父类中的方法的名称，参数个数、类型都完全一致时，就称子类中的这个方法重写了父类中的方法。

重写也是覆盖 override

2.前提：


必须要有继承关系
```

3. 进程和线程的区别 

```
1. 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位
2. 
内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
```



